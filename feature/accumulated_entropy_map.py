import platform
import os
import numpy as np
import cv2
import glob


class AccumulatedEntropyMap:
    def __init__(self, src_file_path=None, use_accumulate=True, level=1, window_size=1024, stride=256, theta=0.2):
        self.src_file_path = src_file_path
        self.use_accumulate = use_accumulate
        self.level = level
        self.window_size = window_size
        self.window_stride = stride
        self.theta = theta

        self.byte_windows = None
        self.frequency_windows = None
        self.probability_windows = None
        self.entropy_windows = None
        self.accumulated_entropy_windows = None

        self.accumulated_entropy_map = None

    def fit_transform(self):
        if (self.src_file_path is None) or (not os.path.exists(self.src_file_path)):
            raise Exception('Source file does not exists.')

        byte_data = self._get_bytes(self.src_file_path)

        self.byte_windows = self._convert_windows(byte_data)
        self.frequency_windows = self._convert_frequency_windows(self.byte_windows)
        self.probability_windows = self._convert_probability_windows(self.frequency_windows)
        self.entropy_windows = self._convert_entropy_windows(self.probability_windows)
        self.accumulated_entropy_windows = self._convert_accumulated_entropy_windows(self.entropy_windows)

        self.accumulated_entropy_map = self._generate_accumulated_entropy_map(self.entropy_windows, self.accumulated_entropy_windows)

    def _get_bytes(self, file_path):
        if platform.system() == 'Linux':
            byte_data = self._read_bytes_in_linux(file_path)

        elif platform.system() == 'Windows':
            byte_data = self._read_bytes_in_windows(file_path)

        else:
            raise Exception('Invalid operating system')

        return byte_data

    def _read_bytes_in_windows(self, file_path):
        with open(file_path, 'rb') as file_descriptor:
            bytes = file_descriptor.read()

        byte_data = list()
        for byte in bytes:
            byte_data.append(int('{:02X}'.format(byte), 16))

        return byte_data

    def _read_bytes_in_linux(self, file_path):
        with open(file_path, 'rb') as file_descriptor:
            byte_data = map(ord, file_descriptor.read())

        return byte_data

    def _convert_windows(self, byte_data):
        byte_histograms = list()
        for index in range(0, len(byte_data) - self.window_size + 1, self.window_stride):
            window_bytes = byte_data[index: index + self.window_size]

            byte_histograms.append(window_bytes)

        return byte_histograms

    def _convert_frequency_windows(self, byte_histograms):
        frequency_histograms = list()
        for byte_histogram in byte_histograms:
            frequency_histogram = [0] * 256

            for byte in byte_histogram:
                frequency_histogram[byte] = frequency_histogram[byte] + 1

            frequency_histograms.append(frequency_histogram)

        return frequency_histograms

    def _convert_probability_windows(self, frequency_histograms):
        probability_histograms = list()
        for frequency_histogram in frequency_histograms:
            probability_histogram = [0] * 256

            for i in range(0, len(frequency_histogram)):
                if frequency_histogram[i] != 0:
                    probability_histogram[i] = frequency_histogram[i] / float(self.window_size)

            probability_histograms.append(probability_histogram)

        return probability_histograms

    def _convert_entropy_windows(self, probability_histograms):
        entropy_histograms = list()
        for probability_histogram in probability_histograms:
            entropy_histogram = list()

            for probability in probability_histogram:
                entropy_histogram.append(self._get_entropy(probability))

            entropy_histograms.append(entropy_histogram)

        return entropy_histograms

    def _get_entropy(self, probability):
        if probability == 0:
            return 0

        return -(np.log(probability) * probability) - (1 - probability) * np.log(1 - probability)

    def _convert_accumulated_entropy_windows(self, entropy_windows):
        accumulated_entropy_windows = list()

        for entropy_window in entropy_windows:
            if len(accumulated_entropy_windows) > 0:
                accumulated_entropy_window = accumulated_entropy_windows[-1].copy()

            else:
                accumulated_entropy_window = np.zeros(len(entropy_window))

            accumulated_entropy_window = accumulated_entropy_window + entropy_window
            accumulated_entropy_windows.append(accumulated_entropy_window)

        return accumulated_entropy_windows

    def _generate_accumulated_entropy_map(self, entropy_windows, accumulated_entropy_windows):
        accumulated_entropy_map = np.zeros((self.level, len(entropy_windows[-1])))

        interval_points = list()

        interval_value = len(entropy_windows) / self.theta
        for i in range(0, self.level):
            interval_points.append(interval_value * (i + 1))

        for y_index in range(0, len(accumulated_entropy_windows)):
            for x_index in range(0, len(accumulated_entropy_windows[y_index])):
                level_index = -1

                for point in interval_points:
                    level_index += 1

                    if accumulated_entropy_windows[y_index][x_index] < point:
                        break

                if self.use_accumulate is True:
                    accumulated_entropy_map[level_index][x_index] += accumulated_entropy_windows[y_index][x_index]

                else:
                    accumulated_entropy_map[level_index][x_index] += entropy_windows[y_index][x_index]

        return accumulated_entropy_map

    def show(self, file_path=None, dsize=None):
        image_matrix = (self.accumulated_entropy_map * 255).astype(np.uint8)
        if dsize is not None:
            image_matrix = cv2.resize(image_matrix, dsize=dsize)

        if file_path is None:
            cv2.imshow('Accumulated Entropy Map', image_matrix)
            cv2.waitKey(0)

            return

        cv2.imwrite(file_path, image_matrix)

    def show_square_matrix(self, file_path=None, dsize=None):
        image_matrix = (self.accumulated_entropy_map * 255).astype(np.uint8)

        single_array = image_matrix.ravel()
        length = int(np.sqrt(len(single_array)))

        image_matrix = single_array.reshape(length, length)
        if dsize is not None:
            image_matrix = cv2.resize(image_matrix, dsize=dsize)

        if file_path is None:
            cv2.imshow('Accumulated Entropy Map', image_matrix)
            cv2.waitKey(0)

            return

        cv2.imwrite(file_path, image_matrix)


def get_file_name(file_path):
    file_name = os.path.basename(file_path)
    file_name = os.path.splitext(file_name)[0]

    return file_name


def write_accumulated_entropy_map_in_dir(src_dir, dest_dir, level=4, theta=512, use_accumulate=True):
    files = glob.glob(os.path.join(src_dir, '*'))

    print('---------------------------------------------')
    print('Source directory: {0}'.format(src_dir))
    print('Destination directory: {0}'.format(dest_dir))
    print('The number of files: {0}'.format(len(files)))
    print()

    for file_path in files:
        if os.path.isdir(file_path):
            continue

        file_name = get_file_name(file_path)

        dest_file_path = os.path.join(dest_dir, '{0}_{1}.png'.format(file_name, use_accumulate))

        accumulated_entropy_map = AccumulatedEntropyMap(src_file_path=file_path,
                                                        use_accumulate=use_accumulate,
                                                        level=level,
                                                        theta=theta)
        accumulated_entropy_map.fit_transform()
        accumulated_entropy_map.show_square_matrix(dest_file_path)


def write_accumulated_entropy_map_in_file(file_path, dest_dir, level=4, theta=256, use_accumulate=True):
    file_name = get_file_name(file_path)

    dest_file_path = os.path.join(dest_dir, '{0}_{1}.png'.format(file_name, use_accumulate))

    accumulated_entropy_map = AccumulatedEntropyMap(src_file_path=file_path,
                                                    use_accumulate=use_accumulate,
                                                    level=level,
                                                    theta=theta)
    accumulated_entropy_map.fit_transform()
    accumulated_entropy_map.show_square_matrix(dest_file_path)


if __name__ == '__main__':
    SRC_EXE_DIR_PATH = '/home/hadoop/Data/SSecurityData/dataset_behavior_v2/exe'
    DSC_DIR_PATH = '/home/hadoop/byunghyun_histogram/Data/accumulated_entropy_map_image'

    if not os.path.exists(DSC_DIR_PATH):
        os.mkdir(DSC_DIR_PATH)

    families = ['ADWARE', 'BENIGN', 'DOWNLOADER', 'HIDER', 'PACKED', 'REMOTECON', 'REPLICATOR', 'TROJWARE', 'WARN']
    for family in families:
        exe_root_dir_path = os.path.join(SRC_EXE_DIR_PATH, family)

        image_dir_path = os.path.join(DSC_DIR_PATH, family)
        if not os.path.exists(image_dir_path):
            os.mkdir(image_dir_path)

        dir_paths = list()
        exe_paths = list()

        paths = glob.glob(os.path.join(exe_root_dir_path, '*'))
        for path in paths:
            if os.path.isdir(path):
                dir_paths.append(path)

            else:
                exe_paths.append(path)

        for dir_path in dir_paths:
            write_accumulated_entropy_map_in_dir(dir_path, image_dir_path)

        for file_path in exe_paths:
            write_accumulated_entropy_map_in_file(file_path, image_dir_path)
