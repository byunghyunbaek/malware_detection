import platform
import os
import math
import glob
import numpy as np
import matplotlib.pyplot as plt


class RatedWindowEntropyMap:
    def __init__(self, rating_level=1, file_path=None, entropy_histogram=None, window_size=1024, window_stride=256, max_entropy=0.4, load_histogram=False):
        self.rating_level = rating_level
        self.file_path = file_path

        self.window_size = window_size
        self.window_stride = window_stride
        self.max_entropy = max_entropy

        self.byte_histograms = None
        self.frequency_histograms = None
        self.probability_histograms = None
        self.entropy_histograms = None
        self.rated_window_entropy_map = None

        self.fit_transform(entropy_histogram, load_histogram)

    def fit_transform(self, entropy_histogram, load_histogram):
        if entropy_histogram is not None:
            self.rated_window_entropy_map = self._parse_histogram(entropy_histogram)

        elif load_histogram is True:
            self.rated_window_entropy_map = self._load_file(self.file_path)

        elif platform.system() == 'Linux':
            byte_data = self._read_bytes_in_linux(self.file_path)

        elif platform.system() == 'Windows':
            byte_data = self._read_bytes_in_windows(self.file_path)

        else:
            raise Exception('Invalid operating system')

        if self.rated_window_entropy_map is None:
            self.byte_histograms = self._convert_window_histograms(byte_data)
            self.frequency_histograms = self._convert_frequency_histograms(self.byte_histograms)
            self.probability_histograms = self._convert_probability_histograms(self.frequency_histograms)
            self.entropy_histograms = self._convert_entropy_histograms(self.probability_histograms)
            self.rated_window_entropy_map = self._generate_rated_window_entropy_map(self.entropy_histograms)

    def _parse_histogram(self, entropy_histogram):
        entropy_histograms = list()
        entropy_histograms.append(entropy_histogram)

        return entropy_histograms

    def _load_file(self, file_path):
        if file_path is None:
            raise Exception('File path is none. {0}'.format(file_path))

        with open(file_path, 'r') as file_descriptor:
            lines = file_descriptor.readlines()

        line = lines[0].strip()
        values = line.split(' ')

        entropy_histogram = list()
        for value in values:
            entropy_histogram.append(float(value.split(':')[1]))

        entropy_histogram = np.asarray(entropy_histogram)
        entropy_histograms = entropy_histogram.reshape(int(entropy_histogram.shape[0] / 256), 256)

        return entropy_histograms

    def _read_bytes_in_windows(self, file_path):
        if file_path is None:
            raise Exception('File path is none. {0}'.format(file_path))

        with open(file_path, 'r') as file_descriptor:
            lines = file_descriptor.readlines()

        byte_data = list()
        for line in lines:
            line = line.strip()

            values = line.split(' ')
            del values[0]
            for value in values:
                if value == '??':
                    continue

                byte_data.append(int(value, 16))

        # with open(file_path, 'rb') as file_descriptor:
        #     bytes = file_descriptor.read()
        #
        # byte_data = list()
        # for byte in bytes:
        #     byte_data.append(int('{:02X}'.format(byte), 16))

        return byte_data

    def _read_bytes_in_linux(self, file_path):
        if file_path is None:
            raise Exception('File path is none. {0}'.format(file_path))

        with open(file_path, 'rb') as file_descriptor:
            byte_data = map(ord, file_descriptor.read())

        return byte_data

    def _read_test_file(self):
        with open(self.file_path, 'r') as file_descriptor:
            lines = file_descriptor.readlines()

        byte_data = list()

        for line in lines:
            line = line.strip()

            byte_data.append(int(line))

        return byte_data

    def _convert_window_histograms(self, byte_data):
        byte_histograms = list()
        for index in range(0, len(byte_data) - self.window_size + 1, self.window_stride):
            window_bytes = byte_data[index: index + self.window_size]

            byte_histograms.append(window_bytes)

        return byte_histograms

    def _convert_frequency_histograms(self, byte_histograms):
        frequency_histograms = list()
        for byte_histogram in byte_histograms:
            frequency_histogram = [0] * 256

            for byte in byte_histogram:
                frequency_histogram[byte] = frequency_histogram[byte] + 1

            frequency_histograms.append(frequency_histogram)

        return frequency_histograms

    def _convert_probability_histograms(self, frequency_histograms):
        probability_histograms = list()
        for frequency_histogram in frequency_histograms:
            probability_histogram = [0] * 256

            for i in range(0, len(frequency_histogram)):
                if frequency_histogram[i] != 0:
                    probability_histogram[i] = frequency_histogram[i] / self.window_size

            probability_histograms.append(probability_histogram)

        return probability_histograms

    def _convert_entropy_histograms(self, probability_histograms):
        entropy_histograms = list()
        for probability_histogram in probability_histograms:
            entropy_histogram = list()

            for probability in probability_histogram:
                entropy_histogram.append(self._get_entropy(probability))

            entropy_histograms.append(entropy_histogram)

        return entropy_histograms

    def _get_entropy(self, probability):
        if probability == 0:
            return 0

        return -(np.log(probability) * probability)

    def _generate_rated_window_entropy_map(self, entropy_histograms):
        window_entropy_map = list()
        for _ in range(0, self.rating_level):
            window_entropy_map.append([0] * 256)

        control_points = list()

        interval_value = self.max_entropy / self.rating_level
        for i in range(0, self.rating_level):
            control_points.append(interval_value * (i + 1))

        for entropy_histogram in entropy_histograms:
            for bin_index in range(0, len(entropy_histogram)):
                level_index = -1

                for point in control_points:
                    level_index += 1

                    if entropy_histogram[bin_index] < point:
                        break

                window_entropy_map[level_index][bin_index] = window_entropy_map[level_index][bin_index] + entropy_histogram[bin_index]

        return window_entropy_map

    def to_string(self, label):
        feature = '{0}'.format(label)

        index = 0
        for window_entropy in self.rated_window_entropy_map:
            for entropy in window_entropy:
                feature += ' {0}:{1}'.format(index, entropy)

                index += 1

        return feature

    def get_string(self):
        feature = ''

        index = 0
        for window_entropy in self.rated_window_entropy_map:
            for entropy in window_entropy:
                feature += '{0}:{1} '.format(index, entropy)

                index += 1

        return feature


def get_file_name(file_path):
    file_name = os.path.basename(file_path)
    file_name = os.path.splitext(file_name)[0]

    return file_name


if __name__ == '__main__':
    rating_level = 6
    ROOT_EXE_DIR_PATH = r'D:/MS_Data/train'
    DSC_FEATURE_DIR_PATH = r'D:/MS_Data_feature/level_{0}'.format(rating_level)

    if not os.path.exists(DSC_FEATURE_DIR_PATH):
        os.mkdir(DSC_FEATURE_DIR_PATH)

    file_paths = glob.glob(os.path.join(ROOT_EXE_DIR_PATH, '*'))
    for file_path in file_paths:
        print(file_path)
        rated_window_entropy_map = RatedWindowEntropyMap(rating_level=rating_level, file_path=file_path)

        dest_file_path = os.path.join(DSC_FEATURE_DIR_PATH, get_file_name(file_path) + ".wem")
        with open(dest_file_path, 'w') as file_descriptor:
            file_descriptor.write(rated_window_entropy_map.get_string())
